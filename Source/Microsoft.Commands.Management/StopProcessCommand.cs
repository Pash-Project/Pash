// Copyright (C) Pash Contributors. License: GPL/BSD. See https://github.com/Pash-Project/Pash/
using System;
using System.Management.Automation;
using System.Diagnostics;

namespace Microsoft.PowerShell.Commands
{
    /// <summary>
    /// NAME
    ///   Stop-Process
    /// 
    /// DESCRIPTION
    ///   Stops the given process(es) on the system.
    /// 
    /// RELATED PASH COMMANDS
    ///   Start-Process
    ///   
    /// RELATED POSIX COMMANDS
    ///   kill
    ///   killall
    /// </summary>
    [Cmdlet("Stop", "Process", DefaultParameterSetName = "Id", SupportsShouldProcess = true)]
    public sealed class StopProcessCommand : Cmdlet
    {
        protected override void ProcessRecord()
        {
            if (Name != null)
                foreach (String _name in Name)
                    foreach (Process _proc in Process.GetProcessesByName(_name))
                    {
                        if (PassThru.ToBool()) WriteObject(_proc);
                        if (Close.ToBool()) _proc.CloseMainWindow();
                        else _proc.Kill();
                    }
            else if (Id != null)
                foreach (int _id in Id)
                {
                    if (PassThru.ToBool()) WriteObject(Process.GetProcessById(_id));
                    if (Close.ToBool()) Process.GetProcessById(_id).CloseMainWindow();
                    else Process.GetProcessById(_id).Kill();
                }
        }

        // Note: This is not supported in PowerShell proper, but might be extremely useful in Unix systems.
        // and indeed, this is the default behavior of the Unix "kill" command.
        // I asked a few PowerShell pro-types if they'd find it useful and they liked the idea.
        /// <summary>
        /// Sends a signal to the process asking it to terminate, perhaps giving the process time to save state. If the process is deadlocked (frozen) this will likely not do anything.
        /// </summary>
        [Parameter]
        public SwitchParameter Close { get; set; }

        /// <summary>
        /// Stop processes with the given id numbers.
        /// </summary>
        [Parameter(Position = 0, ParameterSetName = "Id", Mandatory = true, ValueFromPipelineByPropertyName = true)]
        public int[] Id { get; set; }

        /// <summary>
        /// Stop processes with the given process names. Any processes which match the given name will be affected.
        /// </summary>
        [Parameter(ParameterSetName = "Name", Mandatory = true, ValueFromPipelineByPropertyName = true), Alias(new string[] { "ProcessName" })]
        public string[] Name { get; set; }

        /// <summary>
        /// Passes all objects passed into the cmdlet or generated by the cmdlet along the pipeline.
        /// </summary>
        [Parameter]
        public SwitchParameter PassThru { get; set; }

        // This parameter currently doesn't do anything. 
        // It doesn't seem needed (I could be, and probably am, wrong) because of the above ValueFromPipeline attribute
        // of the Id and Name parameters should catch any incoming Process types and deal with them the correct way.
        // But since this is a PoSH parameter, and in the name of compatability we should include it anyway.
        [Parameter]
        public Process[] InputObject { get; set; }
    }


}
